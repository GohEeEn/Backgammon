package game;

import java.util.Random;

/**
 * Dice class that has every functionalities that related to dice roll
 *
 * @author Ee En Goh - 17202691
 */
public class Dice {

	/* Instance variables */
	
	/** Used to generate random dice roll value */
	private Random rand;
	
	/** Integer array that stores both 2 dice roll values per game turn */ 
	private int[] diceRoll;
	
	/** Number of disk moves at the current game turn */
	private int numberOfMoves;
	
	/** Boolean value to indicate if both the current dice roll value are the same */
	private boolean beaver;
	
	/**
	 * Constructor that creates a new Random object
	 */
	public Dice() {
		this.rand = new Random();	
		diceRoll = new int[4];
		numberOfMoves = 0;
		beaver = false;
	}
	
	// ----- Getter and Setter Methods ----- 
	
	/**
	 * Generate a random number in the range 1 - 6 for each dice
	 * @return generate a random integer in the range 1 - 6 generated by the Random object
	 */
	public int getRandNum() {
		return 1 + rand.nextInt(6);
	}

	/**
	 * Getter method that get the dice roll value of the current to be used for moving disk
	 * @param The index of the target die
	 * @return The dice roll value of the target die
	 */
	public int getDiceRoll(int index) {
		return this.diceRoll[index];
	}
	
	public int[] getDiceRollSet() {
		return this.diceRoll;
	}

	/**
	 * Assign 2 individual dice value to the dice roll array, which is same as the total number of move should be made 
	 * @param value1	The new first dice-roll value 
	 * @param value2	The new second dice-roll value
	 */
	public void setDiceRoll(int value1, int value2) {
		this.diceRoll[0] = value1;
		this.diceRoll[1] = value2;
	}
	
	/**
	 * @return The total number of move choices can be made 
	 */
	public int getNumberOfMoves() {
		return this.numberOfMoves;
	}
	
	/*
	public void setNumberOfMoves() {
		this.numberOfMoves--;
	}
	*/
	
	/**
	 * @return True if the dice roll value in the current round is a beaver play, else false
	 */
	public boolean isBeaverPlay() {
		return this.beaver;
	}
	
	/**
	 * Restore the state of dice roll in current game play<br>
	 * Beaver / Normal Play -> Normal Play
	 */
	public void restorePlayState() {
		this.beaver = false;
	}
	
	// ----- End of Getter and Setter Methods -----
	
	/**
	 * Method that executes different way of the value assignment to the array, depends on the given instruction in String
	 * @param s	String that indicates the specific case(s) of game play
	 * @return	The string that related to the result of the dice roll (normal 2 dices result or beavers play)
	 */
	public String rollDice(String s) {
		
		setDiceRoll(getRandNum(),getRandNum());
		
		switch(s) {
			case "turn":	// Case for choosing player's turn, no same dice-roll value 
				while(compareTo() == 0) 
					setDiceRoll(getRandNum(),getRandNum());
				break;
			case "move":	// Case in game turn, beaver game-play if both dice-value are the same
				if(compareTo() == 0) {
					diceRoll[3] = diceRoll[2] = diceRoll[0] = diceRoll[1]; 		//TODO
					numberOfMoves = 4;
					beaver = true;
					return returnFourDiceRolls();
				}
		}
		numberOfMoves = 2;
		return returnTwoDiceRolls();
	}
	
	/**
	 * @return String generated for notify the player that he/she got a normal dice play
	 */
	private String returnTwoDiceRolls() {
		return "Rolled: " + diceRoll[0] + " and " + diceRoll[1] + " , the current player can make " + (diceRoll[0] + diceRoll[1]) + " disk move(s)";
	}
	
	/**
	 * @return String generated for notify the player that he/she got a beaver
	 */
	private String returnFourDiceRolls() {
		return "Rolled: " + diceRoll[0] + ", " + diceRoll[1] + ", " + diceRoll[2] + " and " + diceRoll[3]+ " , you can move at most " + (diceRoll[0] * 4) + " steps in a command";
	}
	
	/**
	 * Boolean method that check if the move instruction given is mathematically valid
	 * @param moveFrom	The pip index where the checker is will move from
	 * @param moveTo	The pip index where the checker is will move to
	 * @return			True, if the given move is mathematically valid, else false
	 */
	public boolean isMoveAccordingToDiceRoll(int moveFrom, int moveTo) {
		return (Math.abs(moveFrom - moveTo)) == diceRoll[0] || (Math.abs(moveFrom - moveTo)) == diceRoll[1];
	}
	
	/**
	 * Method to calculate the remaining move should be made by the players, depends on the disk move(s) have been made previously  
	 * @param moveFrom	Where the disk moved from in the previous move
	 * @param moveTo	Where the disk moved to in the previous move
	 * @return	String, message that related with the remaining move shall be made by the current player
	 */
	public String returnRemainingRolls(int moveFrom, int moveTo) { // TODO
		
		if(Math.abs(moveFrom - moveTo) == diceRoll[0])
			diceRoll[0] = 0;
		else if(Math.abs(moveFrom - moveTo) == diceRoll[1])
			diceRoll[1] = 0;
		else if(Math.abs(moveFrom - moveTo) == diceRoll[2])
			diceRoll[2] = 0;
		else if(Math.abs(moveFrom - moveTo) == diceRoll[3])
			diceRoll[3] = 0;
		
		numberOfMoves--;
		
		int totalAvailableMove = 0;
		String output = "Remaining moves : ";
		
		for(int i = 0 ; i <= numberOfMoves ; i++) { 
			if(diceRoll[i] != 0) {
				output += diceRoll[i] + " ";
				totalAvailableMove += diceRoll[i];
			}
		}
		
		output += " , you can still make " + totalAvailableMove + " disk move(s) in total";
		
		return output;
	}
	
	/** 
	 * Method that used compare the both 2 dice-roll value, and return a defined-integer value to shows the comparing result 
	 * @return 0 if they are equal, 1 if dice 1 > dice 0, else -1 for dice 1 < dice 0
	 */
	public int compareTo() {
		
		if (diceRoll[0] == diceRoll[1])
			return 0;
		else if (diceRoll[0] <  diceRoll[1]) 
			return 1;
		else
			return -1;
	}
}
