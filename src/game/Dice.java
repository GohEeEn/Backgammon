package game;

import java.util.ArrayList;
import java.util.Random;

/**
 * Dice class that has every functionalities that related to dice roll
 *
 * @author Ee En Goh - 17202691
 * @author Ferdia Fagan - 16372803
 */
public class Dice {

	/* Instance variables */
	
	/** Used to generate random dice roll value */
	private Random rand;
	
	/** Integer array that stores both 2 dice roll values per game turn */ 
	private ArrayList<Integer> diceRoll;
	
	/** Number of disk moves at the current game turn */
	private int numberOfMoves;
	
	/** Boolean value to indicate if both the current dice roll value are the same */
	private boolean beaver;
	
	/**
	 * Constructor that creates a new Random object
	 */
	public Dice() {
		this.rand = new Random();	
		diceRoll = new ArrayList<Integer>();
		numberOfMoves = 0;
		beaver = false;
	}
	
	// ----- Getter and Setter Methods ----- 
	
	/**
	 * Generate a random number in the range 1 - 6 for each dice
	 * @return generate a random integer in the range 1 - 6 generated by the Random object
	 */
	public int getRandNum() {
		return 1 + rand.nextInt(6);
	}

	/**
	 * Getter method that get the dice roll value of the current to be used for moving disk
	 * @param The index of the target die
	 * @return The dice roll value of the target die
	 */
	public int getDiceRoll(int index) {
		return this.diceRoll.get(index);		// Get the dice
	}
	
	public ArrayList<Integer> getDiceRollSet() {
		return this.diceRoll;
	}

	/**
	 * Assign 2 individual dice value to the dice roll array, which is same as the total number of move should be made 
	 * @param value1	The new first dice-roll value 
	 * @param value2	The new second dice-roll value
	 */
	public void setDiceRoll(int value1, int value2) {
		this.diceRoll.add(value1);
		this.diceRoll.add(value2);
	}
	
	/**
	 * @return The total number of move choices can be made 
	 */
	public int getNumberOfDiceLeft() {
		return this.numberOfMoves;
	}
	
	/*
	public void setNumberOfMoves() {
		this.numberOfMoves--;
	}
	*/
	
	/**
	 * @return True if the dice roll value in the current round is a beaver play, else false
	 */
	public boolean isBeaverPlay() {
		return this.beaver;
	}
	
	/**
	 * Restore the state of dice roll in current game play<br>
	 * Beaver / Normal Play -> Normal Play
	 */
	public void restorePlayState() {
		this.beaver = false;
	}
	
	// ----- End of Getter and Setter Methods -----
	
	/**
	 * Method that executes different way of the value assignment to the array, depends on the given instruction in String
	 * @param s	String that indicates the specific case(s) of game play
	 * @return	The string that related to the result of the dice roll (normal 2 dices result or beavers play)
	 */
	public String rollDice(String command) {
		
		diceRoll.clear();// Clear the dice
		
		setDiceRoll(getRandNum(),getRandNum());
		
		switch(command) {
			case "turn":	// Case for choosing player's turn, no same dice-roll value 
				while(compareTo() == 0) 
					return rollDice(command);
				break;
			case "move":	// Case in game turn, beaver game-play if both dice-value are the same
				if(compareTo() == 0) {
					diceRoll.add(diceRoll.get(0));
					diceRoll.add(diceRoll.get(0));
					numberOfMoves = 4;
					beaver = true;
					return returnFourDiceRolls();
				}
		}
		numberOfMoves = 2;
		return returnTwoDiceRolls();
	}
	
	/**
	 * @return String generated for notify the player that he/she got a normal dice play
	 */
	private String returnTwoDiceRolls() {
		return "Rolled: " + diceRoll.get(0) + " and " + diceRoll.get(1) + " , the current player can make " + (diceRoll.get(0) + diceRoll.get(1)) + " disk move(s)";
	}
	
	/**
	 * @return String generated for notify the player that he/she got a beaver
	 */
	private String returnFourDiceRolls() {
		return "Rolled: " + diceRoll.get(0) + ", " + diceRoll.get(1) + ", " + diceRoll.get(2) + " and " + diceRoll.get(3)+ " , you can move at most " + (diceRoll.get(0) * 4) + " steps in a command";
	}
	
	
	/**
	 * Boolean method that check if the move instruction given is mathematically valid
	 * @param moveFrom	The pip index where the checker is will move from
	 * @param moveTo	The pip index where the checker is will move to
	 * @return			True, if the given move is mathematically valid, else false
	 */
	/***
	public boolean isMoveAccordingToDiceRoll(int moveFrom, int moveTo) {
		return (Math.abs(moveFrom - moveTo)) == diceRoll[0] || (Math.abs(moveFrom - moveTo)) == diceRoll[1];
	}
	***/
	
	/**
	 * Method to calculate the remaining move should be made by the players, depends on the disk move(s) have been made previously  
	 * @param moveFrom	Where the disk moved from in the previous move
	 * @param moveTo	Where the disk moved to in the previous move
	 * @return	String, message that related with the remaining move shall be made by the current player
	 */
	public String returnRemainingRolls(int diceUsed) { // TODO
		
		boolean containsDice = false;
		
		Integer sumOfDiceRolls = 0;
		
		// Check if contains this dice roll
		for (Integer dice : diceRoll) {
			sumOfDiceRolls += dice;
			if(diceUsed == dice) {
				containsDice = true;
				break;
			}
		}
		
		
		if(containsDice) {
			
			System.out.println("dice used is " + diceUsed);
			// Remove the dice roll
			for (Integer dice : diceRoll) {
				if(diceUsed == dice) {
					diceRoll.remove(dice);
					System.out.println("remove dice");
					break;
				}
			}
			
			numberOfMoves--;
			
			int totalAvailableMove = 0;
			String output = "Remaining moves : ";
			
			for(int i = 0 ; i < numberOfMoves ; i++) { 
					output += diceRoll.get(i) + " ";
					totalAvailableMove += diceRoll.get(i);
				
			}
			
			output += " , you can still make " + totalAvailableMove + " disk move(s) in total";
			
			return output;
		}
		
		else {
			
			for (Integer dice : diceRoll) {
				if(sumOfDiceRolls == dice) {
					numberOfMoves = 0;
					break;
				}
			}
			return null;
		}
		

	}
	
	/** 
	 * Method that used compare the both 2 dice-roll value, and return a defined-integer value to shows the comparing result 
	 * @return 0 if they are equal, 1 if dice 1 > dice 0, else -1 for dice 1 < dice 0
	 */
	public int compareTo() {
		
		if (diceRoll.get(0) == diceRoll.get(1))
			return 0;
		else if (diceRoll.get(0) < diceRoll.get(1)) 
			return 1;
		else
			return -1;
	}
}
